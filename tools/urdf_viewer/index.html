<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anzym Robot — URDF Viewer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: #0a0a0f;
            color: #e0e0e8;
            overflow: hidden;
            height: 100vh;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        canvas {
            display: block;
        }

        /* Header bar */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 52px;
            background: rgba(10, 10, 18, 0.85);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 100;
            gap: 14px;
        }

        #header .logo {
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            border-radius: 7px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
            color: white;
        }

        #header h1 {
            font-size: 15px;
            font-weight: 600;
            letter-spacing: -0.3px;
        }

        #header .subtitle {
            font-size: 12px;
            color: #888;
            font-weight: 400;
        }

        #header .spacer {
            flex: 1;
        }

        #header .badge {
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 500;
            background: rgba(99, 102, 241, 0.15);
            color: #a5b4fc;
            border: 1px solid rgba(99, 102, 241, 0.2);
        }

        /* Side panel */
        #panel {
            position: fixed;
            top: 52px;
            right: 0;
            width: 320px;
            height: calc(100vh - 52px);
            background: rgba(14, 14, 22, 0.92);
            backdrop-filter: blur(24px);
            border-left: 1px solid rgba(255, 255, 255, 0.06);
            z-index: 90;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }

        #panel.collapsed {
            transform: translateX(320px);
        }

        #panel-toggle {
            position: fixed;
            top: 62px;
            right: 328px;
            z-index: 91;
            background: rgba(14, 14, 22, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: #aaa;
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        #panel-toggle:hover {
            background: rgba(99, 102, 241, 0.2);
            color: #a5b4fc;
        }

        .panel-section {
            padding: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
        }

        .panel-section h3 {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 12px;
        }

        /* Joint slider */
        .joint-control {
            margin-bottom: 12px;
        }

        .joint-control label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .joint-control .joint-name {
            font-size: 13px;
            font-weight: 500;
            color: #c8c8d4;
        }

        .joint-control .joint-value {
            font-size: 11px;
            font-family: 'SF Mono', 'Fira Code', monospace;
            color: #8b5cf6;
            background: rgba(139, 92, 246, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .joint-control input[type="range"] {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .joint-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            box-shadow: 0 0 8px rgba(99, 102, 241, 0.4);
            cursor: pointer;
            transition: transform 0.15s;
        }

        .joint-control input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* Link tree */
        .link-tree-item {
            display: flex;
            align-items: center;
            padding: 4px 0;
            font-size: 12px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .link-tree-item:hover {
            color: #a5b4fc;
        }

        .link-tree-item .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .link-tree-item .dot.green {
            background: #4ade80;
        }

        .link-tree-item .dot.white {
            background: #94a3b8;
        }

        .link-tree-item .dot.fixed {
            background: #475569;
        }

        /* View buttons */
        .view-btn-row {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .view-btn {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.03);
            color: #aaa;
            cursor: pointer;
            transition: all 0.2s;
        }

        .view-btn:hover {
            background: rgba(99, 102, 241, 0.15);
            color: #a5b4fc;
            border-color: rgba(99, 102, 241, 0.3);
        }

        .view-btn.active {
            background: rgba(99, 102, 241, 0.2);
            color: #a5b4fc;
            border-color: rgba(99, 102, 241, 0.4);
        }

        /* Loading overlay */
        #loading {
            position: fixed;
            inset: 0;
            background: #0a0a0f;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(99, 102, 241, 0.15);
            border-top-color: #6366f1;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        #loading p {
            margin-top: 16px;
            font-size: 14px;
            color: #666;
        }

        #loading #load-status {
            margin-top: 6px;
            font-size: 12px;
            color: #444;
        }

        /* Info HUD */
        #info-hud {
            position: fixed;
            bottom: 16px;
            left: 16px;
            font-size: 11px;
            color: #555;
            z-index: 90;
            line-height: 1.6;
        }

        /* Scroll styling */
        #panel::-webkit-scrollbar {
            width: 4px;
        }

        #panel::-webkit-scrollbar-track {
            background: transparent;
        }

        #panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        /* Reset button */
        .reset-btn {
            padding: 6px 14px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            border: 1px solid rgba(239, 68, 68, 0.2);
            background: rgba(239, 68, 68, 0.08);
            color: #f87171;
            cursor: pointer;
            transition: all 0.2s;
        }

        .reset-btn:hover {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.4);
        }
    </style>
</head>

<body>

    <div id="loading">
        <div class="spinner"></div>
        <p>Loading Robot Model</p>
        <div id="load-status">Fetching URDF...</div>
    </div>

    <div id="header">
        <div class="logo">A</div>
        <h1>Anzym Robot</h1>
        <span class="subtitle">URDF Viewer</span>
        <div class="spacer"></div>
        <span class="badge" id="link-count">—</span>
        <span class="badge" id="joint-count">—</span>
    </div>

    <button id="panel-toggle" title="Toggle Panel">◀</button>

    <div id="panel">
        <div class="panel-section">
            <h3>Camera Views</h3>
            <div class="view-btn-row">
                <button class="view-btn active" data-view="perspective">Perspective</button>
                <button class="view-btn" data-view="front">Front</button>
                <button class="view-btn" data-view="side">Side</button>
                <button class="view-btn" data-view="top">Top</button>
            </div>
        </div>

        <div class="panel-section">
            <h3>Display</h3>
            <div class="view-btn-row">
                <button class="view-btn active" id="btn-visual">Visual</button>
                <button class="view-btn" id="btn-wireframe">Wireframe</button>
                <button class="view-btn" id="btn-axes">Joint Axes</button>
                <button class="view-btn active" id="btn-grid">Grid</button>
            </div>
        </div>

        <div class="panel-section" id="joints-section">
            <h3>Joint Controls</h3>
            <div id="joints-container"></div>
            <div style="margin-top: 10px;">
                <button class="reset-btn" id="btn-reset">Reset All Joints</button>
            </div>
        </div>

        <div class="panel-section">
            <h3>Link Hierarchy</h3>
            <div id="link-tree"></div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <div id="info-hud">
        Scroll to zoom · Drag to orbit · Right-drag to pan
    </div>

    <script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';

        // ===== Globals =====
        let scene, camera, renderer, controls;
        let robotRoot;
        let jointMap = {};
        let linkMeshes = {};
        let jointAxesHelpers = [];
        let gridHelper;
        let showAxes = false;

        // ===== Materials =====
        const MATERIALS = {
            'Green': new THREE.MeshPhysicalMaterial({
                color: 0x1a9e4f,
                metalness: 0.2,
                roughness: 0.35,
                clearcoat: 0.4,
                clearcoatRoughness: 0.2,
            }),
            'White': new THREE.MeshPhysicalMaterial({
                color: 0x9ca3af,
                metalness: 0.3,
                roughness: 0.3,
                clearcoat: 0.5,
                clearcoatRoughness: 0.15,
            }),
            'default': new THREE.MeshPhysicalMaterial({
                color: 0x6366f1,
                metalness: 0.3,
                roughness: 0.4,
            }),
        };

        // ===== Init =====
        function initScene() {
            const container = document.getElementById('canvas-container');

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0f);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.001, 100);
            camera.position.set(0.5, 0.4, 0.5);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.target.set(0, 0.2, 0);
            controls.minDistance = 0.1;
            controls.maxDistance = 5;
            controls.update();

            // Lighting
            scene.add(new THREE.AmbientLight(0x404060, 0.6));

            const mainLight = new THREE.DirectionalLight(0xffffff, 1.8);
            mainLight.position.set(2, 4, 3);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.set(2048, 2048);
            scene.add(mainLight);

            const fillLight = new THREE.DirectionalLight(0x6366f1, 0.4);
            fillLight.position.set(-2, 2, -1);
            scene.add(fillLight);

            const rimLight = new THREE.DirectionalLight(0x8b5cf6, 0.3);
            rimLight.position.set(0, -1, -3);
            scene.add(rimLight);

            // Ground grid
            gridHelper = new THREE.GridHelper(2, 40, 0x1a1a2e, 0x111122);
            scene.add(gridHelper);

            // Ground plane
            const groundGeom = new THREE.PlaneGeometry(4, 4);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x0a0a0f, metalness: 0.8, roughness: 0.6,
                transparent: true, opacity: 0.5,
            });
            const ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.001;
            ground.receiveShadow = true;
            scene.add(ground);

            robotRoot = new THREE.Group();
            // Convert from URDF Z-up to Three.js Y-up
            robotRoot.rotation.x = -Math.PI / 2;
            scene.add(robotRoot);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // ===== STL Loader =====
        function loadMesh(loader, url) {
            return new Promise((resolve, reject) => {
                loader.load(
                    url,
                    (geometry) => resolve(geometry),
                    undefined,
                    (err) => reject(err)
                );
            });
        }

        // ===== URDF Parser =====
        async function loadURDF() {
            setStatus('Fetching URDF...');
            const response = await fetch('/urdf');
            const urdfText = await response.text();
            console.log('URDF fetched, length:', urdfText.length);

            const parser = new DOMParser();
            const xml = parser.parseFromString(urdfText, 'text/xml');
            const robot = xml.querySelector('robot');
            if (!robot) throw new Error('No <robot> element found');

            // Parse materials
            const materialDefs = {};
            robot.querySelectorAll(':scope > material').forEach(mat => {
                const name = mat.getAttribute('name');
                const colorEl = mat.querySelector('color');
                if (colorEl) {
                    const rgba = colorEl.getAttribute('rgba').split(' ').map(Number);
                    materialDefs[name] = { r: rgba[0], g: rgba[1], b: rgba[2] };
                }
            });

            // Parse links
            const linkDefs = {};
            robot.querySelectorAll(':scope > link').forEach(link => {
                const name = link.getAttribute('name');
                const visual = link.querySelector('visual');
                let meshUrl = null, materialName = null;
                if (visual) {
                    const mesh = visual.querySelector('geometry mesh');
                    if (mesh) meshUrl = mesh.getAttribute('filename');
                    const mat = visual.querySelector('material');
                    if (mat) materialName = mat.getAttribute('name');
                }
                linkDefs[name] = { meshUrl, materialName };
            });

            // Parse joints
            const jointDefs = {};
            robot.querySelectorAll(':scope > joint').forEach(joint => {
                const name = joint.getAttribute('name');
                const type = joint.getAttribute('type');
                const parent = joint.querySelector('parent').getAttribute('link');
                const child = joint.querySelector('child').getAttribute('link');

                const originEl = joint.querySelector('origin');
                let xyz = [0, 0, 0], rpy = [0, 0, 0];
                if (originEl) {
                    if (originEl.getAttribute('xyz')) xyz = originEl.getAttribute('xyz').split(' ').map(Number);
                    if (originEl.getAttribute('rpy')) rpy = originEl.getAttribute('rpy').split(' ').map(Number);
                }

                let axis = [0, 0, 1];
                const axisEl = joint.querySelector('axis');
                if (axisEl && axisEl.getAttribute('xyz'))
                    axis = axisEl.getAttribute('xyz').split(' ').map(Number);

                let lower = -Math.PI, upper = Math.PI;
                const limitEl = joint.querySelector('limit');
                if (limitEl) {
                    lower = parseFloat(limitEl.getAttribute('lower') || -Math.PI);
                    upper = parseFloat(limitEl.getAttribute('upper') || Math.PI);
                }

                let mimicTarget = null, mimicMultiplier = 1;
                const mimicEl = joint.querySelector('mimic');
                if (mimicEl) {
                    mimicTarget = mimicEl.getAttribute('joint');
                    mimicMultiplier = parseFloat(mimicEl.getAttribute('multiplier') || 1);
                }

                jointDefs[name] = { type, parent, child, xyz, rpy, axis, lower, upper, mimicTarget, mimicMultiplier };
            });

            document.getElementById('link-count').textContent = `${Object.keys(linkDefs).length} links`;
            document.getElementById('joint-count').textContent = `${Object.keys(jointDefs).length} joints`;

            // Build hierarchy
            setStatus('Loading meshes...');
            console.log('Starting mesh loading...');
            await buildHierarchy(linkDefs, jointDefs);
            console.log('All meshes loaded!');

            return { linkDefs, jointDefs };
        }

        async function buildHierarchy(linkDefs, jointDefs) {
            const linkGroups = {};
            for (const name of Object.keys(linkDefs)) {
                linkGroups[name] = new THREE.Group();
                linkGroups[name].name = name;
            }

            // Load meshes
            const loader = new STLLoader();
            const meshPromises = [];

            for (const [name, def] of Object.entries(linkDefs)) {
                if (def.meshUrl) {
                    console.log('Loading mesh:', def.meshUrl);
                    const promise = loadMesh(loader, def.meshUrl)
                        .then(geometry => {
                            const matName = def.materialName || 'default';
                            const material = MATERIALS[matName] ? MATERIALS[matName].clone() : MATERIALS['default'].clone();
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.castShadow = true;
                            mesh.receiveShadow = true;
                            mesh.name = name + '_mesh';
                            linkGroups[name].add(mesh);
                            linkMeshes[name] = mesh;
                            setStatus(`Loaded ${name}`);
                            console.log('Loaded:', name);
                        })
                        .catch(err => {
                            console.warn(`Failed to load mesh for ${name}:`, err);
                        });
                    meshPromises.push(promise);
                }
            }

            await Promise.all(meshPromises);

            // Build joint hierarchy
            for (const [jointName, jDef] of Object.entries(jointDefs)) {
                const parentGroup = linkGroups[jDef.parent];
                const childGroup = linkGroups[jDef.child];
                if (!parentGroup || !childGroup) continue;

                const jointGroup = new THREE.Group();
                jointGroup.name = 'joint_' + jointName;
                jointGroup.position.set(jDef.xyz[0], jDef.xyz[1], jDef.xyz[2]);
                jointGroup.quaternion.setFromEuler(new THREE.Euler(jDef.rpy[0], jDef.rpy[1], jDef.rpy[2], 'XYZ'));

                const rotGroup = new THREE.Group();
                rotGroup.name = 'rot_' + jointName;
                jointGroup.add(rotGroup);
                rotGroup.add(childGroup);
                parentGroup.add(jointGroup);

                if (jDef.type === 'revolute' || jDef.type === 'continuous') {
                    jointMap[jointName] = {
                        group: rotGroup,
                        axis: new THREE.Vector3(jDef.axis[0], jDef.axis[1], jDef.axis[2]).normalize(),
                        lower: jDef.lower,
                        upper: jDef.upper,
                        type: jDef.type,
                        mimicTarget: jDef.mimicTarget,
                        mimicMultiplier: jDef.mimicMultiplier,
                        value: 0,
                    };

                    const axisHelper = new THREE.ArrowHelper(
                        new THREE.Vector3(jDef.axis[0], jDef.axis[1], jDef.axis[2]).normalize(),
                        new THREE.Vector3(0, 0, 0), 0.04, 0xff4444, 0.01, 0.008
                    );
                    axisHelper.visible = false;
                    rotGroup.add(axisHelper);
                    jointAxesHelpers.push(axisHelper);
                }
            }

            // Find root links
            const childSet = new Set(Object.values(jointDefs).map(j => j.child));
            for (const [name, group] of Object.entries(linkGroups)) {
                if (!childSet.has(name)) {
                    robotRoot.add(group);
                }
            }
        }

        // ===== Joint Control =====
        function setJointAngle(jointName, angle) {
            const joint = jointMap[jointName];
            if (!joint) return;
            joint.value = angle;
            joint.group.quaternion.setFromAxisAngle(joint.axis, angle);

            for (const [name, j] of Object.entries(jointMap)) {
                if (j.mimicTarget === jointName) {
                    const mimicAngle = angle * j.mimicMultiplier;
                    j.value = mimicAngle;
                    j.group.quaternion.setFromAxisAngle(j.axis, mimicAngle);
                }
            }
        }

        // ===== UI Builders =====
        function buildJointUI() {
            const container = document.getElementById('joints-container');
            container.innerHTML = '';

            for (const [name, joint] of Object.entries(jointMap)) {
                if (joint.mimicTarget) continue;

                const div = document.createElement('div');
                div.className = 'joint-control';

                const label = document.createElement('label');
                const nameSpan = document.createElement('span');
                nameSpan.className = 'joint-name';
                nameSpan.textContent = name.replace(/_/g, ' ');

                const valSpan = document.createElement('span');
                valSpan.className = 'joint-value';
                valSpan.textContent = '0.0°';

                label.appendChild(nameSpan);
                label.appendChild(valSpan);

                const slider = document.createElement('input');
                slider.type = 'range';
                slider.min = (joint.lower * 180 / Math.PI).toFixed(1);
                slider.max = (joint.upper * 180 / Math.PI).toFixed(1);
                slider.step = '0.5';
                slider.value = '0';

                slider.addEventListener('input', () => {
                    const deg = parseFloat(slider.value);
                    setJointAngle(name, deg * Math.PI / 180);
                    valSpan.textContent = deg.toFixed(1) + '°';
                });

                div.appendChild(label);
                div.appendChild(slider);
                container.appendChild(div);
            }
        }

        function buildLinkTree(linkDefs, jointDefs) {
            const container = document.getElementById('link-tree');
            container.innerHTML = '';

            const children = {};
            for (const [jName, jDef] of Object.entries(jointDefs)) {
                if (!children[jDef.parent]) children[jDef.parent] = [];
                children[jDef.parent].push({ joint: jName, child: jDef.child, type: jDef.type });
            }

            const childSet = new Set(Object.values(jointDefs).map(j => j.child));
            const roots = Object.keys(linkDefs).filter(l => !childSet.has(l));

            function renderNode(linkName, depth) {
                const div = document.createElement('div');
                div.className = 'link-tree-item';
                div.style.paddingLeft = (depth * 14) + 'px';

                const dot = document.createElement('span');
                dot.className = 'dot';
                const def = linkDefs[linkName];
                if (def && def.materialName === 'Green') dot.classList.add('green');
                else if (def && def.meshUrl) dot.classList.add('white');
                else dot.classList.add('fixed');

                const text = document.createElement('span');
                text.textContent = linkName;

                div.appendChild(dot);
                div.appendChild(text);
                container.appendChild(div);

                if (children[linkName]) {
                    for (const ch of children[linkName])
                        renderNode(ch.child, depth + 1);
                }
            }

            roots.forEach(r => renderNode(r, 0));
        }

        // ===== Camera Views =====
        function setCameraView(view) {
            const target = new THREE.Vector3(0, 0.2, 0);
            const views = {
                perspective: [0.5, 0.4, 0.5],
                front: [0.6, 0.25, 0],
                side: [0, 0.25, 0.6],
                top: [0, 0.8, 0.001],
            };
            const pos = views[view];
            if (!pos) return;

            const startPos = camera.position.clone();
            const endPos = new THREE.Vector3(...pos);
            const startTarget = controls.target.clone();
            const duration = 600;
            const startTime = performance.now();

            function anim(time) {
                const t = Math.min((time - startTime) / duration, 1);
                const ease = 1 - Math.pow(1 - t, 3);
                camera.position.lerpVectors(startPos, endPos, ease);
                controls.target.lerpVectors(startTarget, target, ease);
                controls.update();
                if (t < 1) requestAnimationFrame(anim);
            }
            requestAnimationFrame(anim);

            document.querySelectorAll('[data-view]').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-view="${view}"]`)?.classList.add('active');
        }

        // ===== Events =====
        function setupEvents() {
            document.querySelectorAll('[data-view]').forEach(btn => {
                btn.addEventListener('click', () => setCameraView(btn.dataset.view));
            });

            document.getElementById('panel-toggle').addEventListener('click', () => {
                const panel = document.getElementById('panel');
                panel.classList.toggle('collapsed');
                const btn = document.getElementById('panel-toggle');
                const collapsed = panel.classList.contains('collapsed');
                btn.textContent = collapsed ? '▶' : '◀';
                btn.style.right = collapsed ? '8px' : '328px';
            });

            document.getElementById('btn-reset').addEventListener('click', () => {
                for (const name of Object.keys(jointMap)) setJointAngle(name, 0);
                document.querySelectorAll('#joints-container input[type="range"]').forEach(s => {
                    s.value = 0;
                    s.parentElement.querySelector('.joint-value').textContent = '0.0°';
                });
            });

            document.getElementById('btn-wireframe').addEventListener('click', function () {
                this.classList.toggle('active');
                const wf = this.classList.contains('active');
                for (const mesh of Object.values(linkMeshes)) mesh.material.wireframe = wf;
            });

            document.getElementById('btn-axes').addEventListener('click', function () {
                this.classList.toggle('active');
                jointAxesHelpers.forEach(h => h.visible = this.classList.contains('active'));
            });

            document.getElementById('btn-grid').addEventListener('click', function () {
                this.classList.toggle('active');
                gridHelper.visible = this.classList.contains('active');
            });
        }

        function setStatus(msg) {
            const el = document.getElementById('load-status');
            if (el) el.textContent = msg;
        }

        // ===== Animation Loop =====
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // ===== Main =====
        async function main() {
            initScene();
            animate();

            try {
                const { linkDefs, jointDefs } = await loadURDF();
                buildJointUI();
                buildLinkTree(linkDefs, jointDefs);
                setupEvents();

                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                }, 300);
            } catch (err) {
                console.error('Failed to load URDF:', err);
                setStatus('Error: ' + err.message);
            }
        }

        main();
    </script>
</body>

</html>